# 관계 속성
  - 행위에 의해 발생되는 속성(개체가 원래 가지고 있지 않는 속성)
  - 예를들어 관리자 ---- 등록 ---- 이벤트 의 경우
    - 등록에 일자라는 속성이 들어간다.(이벤트 일자가 아니고 등록이라는 행위의 일자이므로)
    - 하지만 등록에 이벤트 시작일자는 안들어간다(이벤트 시작일자이지 등록 시작 일자가 아니므로)
# 개념적 데이터모델링
  - n:M 관계인 것만 테이블을 가질 수 있다.
  - 1:n 인 경우, 관계속성은 n쪽 개체의 속성으로 관계와 함께 관계+속성으로 들어간다(등록+일자 : 등록일자)
  - 1:n 의 관계에서 1쪽이 부모이고 n쪽이 자식이 되는데 부모의 키가 자식의 FK로 들어가야한다.
  - n:M 의 관계에서는 릴레이션테이블이 생성 되는데, 이 테이블의 키를 선택하여야한다.
    - 양쪽 엔티티의 기본키들을 외래키로 받아서 두개의 복합속성으로 키를 구성(식별관계)
    - 새로운 키를 생성하여 사용(비식별관계)
# 논리적 데이터모델링(+정규화)
  - 예시
    - 이름  나이   주소   주민번호   핸드폰번호     이메일
    - 홍길동 18    한양     222      010-2222-3333  
    - 김길동 20    대전      
    - 홍길동 18    한양     
  - key
    - 기본키
      - ID 사용
    - 후보키
      - 주민번호, 핸드폰번호, 이메일
    - 대리키 : 현재 테이블의 속성중에 기본키로 사용할 수 있는 속성이 없는경우 만들어 사용하는 대리키
      - 아이디, 숫자코드, 숫자 가능
    - 복합키(슈퍼키)
    - 외래키
  - 테이블의 속성
    - entity = 개체
    - 레코드 - 객체
  - 정규화 normalization
    - 표준화(데이터베이스에서 말하는 테이블의 가장 표준화된 방식이 무엇인가?)
    - 파일과 테이블의 차이 : 중복 유무
    - 즉, 정규화의 중점은 중복을 제거 하는 것(결함을 없애기 위해)
      - 테이블은 무결성을 갖고 있음
    1. 제1 정규화
      - 테이블의 하나의 컬럼이 하나의 값만 가질 수 있도록 하는 것
      - 따로 자식 테이블로 만듬
    2. 제2 정규화
      - 기본키 그룹에 부분함수종속인 속성이 존재하면 안됨.
      - 부분 함수종속인 속성이 존재한다면 걔네 부모에게 돌려줘라 이것임.
    3. 제3 정규화
      - 재사용되는 데이터가 존재(속성에 새겻이 아닌 재사용되는 올드버전이 들어와 있는가?) - 이행적 종속
        - 이행적 종속 : x(기본키) ---> y ---> z 인 관계가 있을때, z가 x에만 종속 되는 것이 아니라, 다른 속성인 y에도 종속되어 있을때
        - 기본키에만 종속된 것이 아니라, 다른 부모의 키에도 종속되어 있는 속성이 있다면 제거를 해줘야 한다.
      - 따로 부모 테이블로 만들고 그 부모테이블의 키를 참조(키는 중복 가능)
    4. 제4 정규화
      - 다대 다 관계에서는 관계를 액션 엔티티로 분류해라!
      

# 물리적 데이터모델링(데이터 타입, check constraint)
  - 정리된 테이블들의 컬럼 데이터 타입 설정
  - 제약조건 설정
    - 도메인 : 속성 제약조건(유효값 범위)
      - not null, default, check
      - 현재 시간과 같은 값을 default로 넣어줄때는 dual table(가상테이블)에 있는 날짜 정보를 가져오는 식으로 사용(SYSDATE, SYSTIMESTAMP)
    - 엔티티 : 레코드 제약조건(속성이 올바른 값들로 이루어 졋더라도, 키가 중복해서 들어가는 등 레코드 단위로 제약조건을 만족 시키지 못하면 무결성 위배 - 레코드 식별 불가능)
      - PRIMARY KEY, UNIQUE
    - 릴레이션
      - 참조 무결성을 위한 제약조건으로서 외래키 제약조건을 걸어줌

# 설계 : 계획을 도표화, 문서화 하는것
  - 개념설계
  - 논리설계
  - 물리설계
# 구현
# 테스트
