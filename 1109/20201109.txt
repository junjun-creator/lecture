CSS

선택자 : 인라인 스타일을 지양하기 위해 사용하는것(집중화) > 스타일을 적용하기 위한 대상을 선택하는 것

선택의 범위를 좁히기 : 태그의 이름으로는 선택되는 범위가 너무 넓음.
		header>h1('>' 자식연산자. 헤더 아래의 첫번째 자식만 찾음)

인접 형제 결합자 A + B
요소 A와 B가 같은 부모를 가지며 B가 A를 바로 뒤따라야 하도록 지정합니다.
일반 형제 결합자 A ~ B
요소 A와 B가 같은 부모를 가지며 B가 A를 뒤따라야 하도록 지정합니다. 그러나 B가 A의 바로 옆에 위치해야 할 필요는 없습니다.
자식 결합자 A > B
요소 B가 A의 바로 밑에 위치해야 하도록 지정합니다.
자손 결합자 A B
요소 B가 A의 밑에 위치해야 하도록 지정합니다. 그러나 B가 A의 바로 아래에 있을 필요는 없습니다.
열 결합자 A || B (실험중인 결합자)
요소 B가 표의 열 A 안에 위치해야 하도록 지정합니다. 여러 열에 걸친 요소는, 각각의 열 모두에 대해 안쪽에 위치한 것으로 간주합니다.

선택자로서 이름을 부여하여 사용하는 방법 : class , id

***** css는 작성된 순서대로 적용된다. but 우선순위가 존재한다. 속성, id, class, 태그,상속 순서 *****

input[type="text"]{
            background-color: pink;
        }

해당 속성을 가진 태그에만 속성을 입히고 싶을 때

2개 이상의 결합자들을 묶어서 > 복합
태그.클래스이름 >> 해당태그의 해당 클래스 이름을 갖는 것

(번외 : header는 제목을 포함하는 박스. nav를 제외하고 모든 section은 헤더를 가질 수 있음)

combinator를 사용하여 속성을 입히는 경우, 해당 태그의 자식(자손)태그에 속성이 상속된다.
하지만 직접적으로 그 자식(자손)태그에 속성이 입혀져 있는 경우에는 이를 이길 수 없다.

css 주석 방식 /**/ or --(한줄주석)

+연산자 : 바로 다음의 형제를 찾음. 중간에 다른게 껴있으면 안됨
~연산자 : 순서와 관계 없이 형제를 찾음

h1.h1
section > .h1	// 이 셋중에서 범위가 좁을수록 우선순위가 높음 >> section
.h1

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
클라우드 서비스

SAS software
HAS hardware as a service
FAS flatform

+ PDB pluggable database >> 플러그처럼 뺏다꽂았다 할 수 있는 데이터베이스(클라우드)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

database
테이블스페이스 : 데이터가 담기는 공간

SQL > ddl, dml, dcl
