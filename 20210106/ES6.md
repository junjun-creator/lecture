오늘은 ES6 6번째 시간입니다

> ## Today I Learned
  - Symbol
  - Promise
  
### Symbol
  - 내장 객체 클래스
  - 고유한 값을 생성
  - 왜 만들었나?
    - 다형성 : 자바스크립트는 태생이 다형성을 갖고있어서 인터페이스를 구현하지 않음
    - 자바스크립트는 함수로 어디든 꽂아서 쓸 수 있음
    - 약속된 '로직을 꽂아서' 사용하기 위해 만듬(인터페이스를 구현하는 목적 처럼)
  - 약속된 로직으로서 인터페이스와 같은 역할을 할 수 있게끔 하기 위해 만듬
  
![](https://images.velog.io/images/junjun-creator/post/b1339b6e-7aa5-464a-b8b6-43b2c58b0b50/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-01-06%20%EC%98%A4%EC%A0%84%2010.26.08.png)

  - Symbol 정리
    - 자바스크립트 내에서 마치 라이브러리를 만드는 것 처럼
    - 약속된 함수를 구현해야만 사용할 수 있는 기능이 있다면?
    - 그 약속을 정의하는 것이 Symbol
    
![](https://images.velog.io/images/junjun-creator/post/f6990c55-81fd-465b-8289-8dc84effbcf7/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-01-06%20%EC%98%A4%ED%9B%84%201.25.03.png)

### Promise
  - 자바스크립트는 비동기 작업을 함수의 중첩으로 해결한다.
  - 이것을 콜백 지옥이라고 하는데 이로부터 해방될 방법이 없을까?
  - 이것이 Promise가 등장한 이유이다.
  - 먼저 기존 중첩형식을 보자.

![](https://images.velog.io/images/junjun-creator/post/253c96bb-47e7-42bb-a635-167ffa6bde96/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-01-06%20%EC%98%A4%ED%9B%84%201.28.22.png)

  - 마치 DB에서 데이터를 가져오는데 오랜 시간이 걸리는 것 처럼 예제를 만들어주기 위해 비동기 함수인 setTimeout을 사용하였다.
    - 결과 : "get요청 이루어짐" > "메인 스레드~" > (10초뒤)"공지사항 1" 순서로 실행됨
  - 10초뒤에 콜백함수가 실행되게 하기 위하여 함수 전체를 인자로 전달하고, 함수의 중첩으로 이를 실행하고 있는 모습을 볼 수 있다.
  - 우리는 이를 통해, 인자로 함수를 전달하는 것과, 함수의 중첩을 제거하고 싶은 욕심이 생긴다.

![](https://images.velog.io/images/junjun-creator/post/03c6c0f8-ce35-444b-b442-219c835b1f59/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-01-06%20%EC%98%A4%ED%9B%84%201.32.43.png)

  - Promise는 비동기작업의 완료(실패)의 결과를 알려주는 객체이다.
    - 위임함수(인자로 함수가 전달되는것)를 제거 할 수 있다.
  - 비동기 작업 처리 완료시 resolve, 실패시 reject 메소드를 실행하게 되는데, 이는 각각 then,catch로 전달된 함수가 실행된다.
  - then과 catch를 활용하여 비동기함수들을 연결하여 실행할 수 도 있다.
    - then의 결과로 다음 비동기 함수를 return하는 경우, 실행 결과에 따라 그 다음에 위치한 then 또는 catch가 실행된다.
