캡슐화

상속

다형성



1.알맹이 : 값을 가지는 그릇(개념단위의 그릇) - entity
2.서비스 : 알맹이들을 가지고 있던지 가져오던지 해서 알맹이들을 제공해주는 서비스
3.껍데기 : 사용자의 입/출력을 도와주는 사용자 인터페이스

entity를 사용할 경우 장점
> 형식명에 의미를 부여할 수 있음.(가독성 up)
> 여러 자료를 묶어서 한번에 들고 다닐수 있음!(도시락 반찬을 다 따로 들고다니면 불편하다)

entity의 중복을 피하기 위해 패키지를 사용
그럼 패키지 명은 중복될수 있지 않느냐?? >> 그래서 패키지 명을 도메인 네임을 사용!!
도메인 네임은 유일하므로!

import > ctrl + shift + o(임포트 관리)

Lotto 클래스 안의 내용을 밖에서 사용하지 못하게 막음으로써(안에다 두면) 수정이 되엇을때
오류가 나는 범위를 한정할 수 있다.

하고싶은 일들을 거시적으로 이름으로 표현(함수)하고 구체적인 내용은 함수 안에서 구현하면 된다.
이때 entity의 변수명을 바꿔버리면 에러가 난다!!!
이때 오류의 범위를 최소화 하기위해! 캡슐화!!!를 한다. 연관된 변수와 메소드를 함께 두는것!
(구현 내용을 외부에서 모르게 은닉)
캡슐화를 하면, 오류가 나더라도 한 곳에 오류가 집중되어 있으므로 수정하기 좋다.

Lotto에서 선언된 nums 배열을 초기화를 해야하는데, 초기화 하는 함수를 만들면
초기화를 다른곳에서도 또 사용할 수 있으므로 좋지 않다.

객체중심으로 기능을 구현하는 방법을 만들자!
Lotto,gen() 보다는 >>> lotto.gen() 으로 사용할 수 있도록!

Lotto.gen();  // static method (함수)
lotto.gen(); // instance method (메서드) 함수를 객체 위주로 사용할수 있게 함

자바에서는 함수를 클래스 안에 구현하도록 하고 있으니
다른 클래스에 있는 함수를 구별하는 구분자로서 Lotto 이름을 붙여서 쓴다.
static : entity에

instance method = 객체를 통해서 호출되는 메소드.
lotto.gen(); >> this는 lotto 를 가리킨다.

Lotto lotto = new Lotto();
		생성자 함수. 얘를 호출하는 방법은 객체를 통해서만 가능한데,
		갓 만들어진 객체를 통해서만 호출이 가능하다.(즉 객체 생성할때만)

앞으로는 객체 중심의 프로그래밍을 할 것이다.
객체는 캡슐 덩어리 : 데이터 구조 + 기능
(인스턴스) 메소드 + (스태틱) 메소드
생성자 : 초기화

앞으로 배울것
Getters / Setters  >> 캡슐의 은닉화(감춤)
상속 override / overload
인터페이스

Getters : 클래스의 구조를 숨기고, 값을 가져올수 있도록 함.
캡슐화를 깨지 못하도록 private 키워드 등장
캡슐화를 깨지 않고 값을 가져올(입력할)수 있는 방법이 getter setter

캡슐화 한 클래스를 사용하는 방법 2가지
1> 객체 생성해서 사용
2> 

부품을 조합해서 쓴다(상속 , Has a 상속)
public class 컴퓨터{
   private Hdd hdd; >> 부품을 가진것
}

제품을 약간만 수정해서 쓴다(상속, Is a 상속) 틀(프레임워크)
public class 뉴렉컴퓨터 extends 컴퓨터{
	>>기존에 있는걸 가져다가 고쳐 쓰는것.
}

기존의 틀이 있을때, 그 틀을 가져다 쓰려면 상속해서 확장해줘야함(extends)